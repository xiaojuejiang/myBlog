/*
Navicat MySQL Data Transfer

Source Server         : localhost_3306
Source Server Version : 50553
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50553
File Encoding         : 65001

Date: 2018-11-26 17:07:25
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `ctime` varchar(255) NOT NULL,
  `author_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES ('20', 'nodejsDay02', '## node day02 ##\r\n\r\n### fs模块 ###\r\n\r\n#### stat方法 ####\r\n\r\n获取文件或目录的信息\r\n\r\n参数1: 要获取的文件或目录的路径\r\n\r\n参数2: 回调函数, 回调函数中有两个参数, 第一个是错误信息err, 第二个是文件或目录的信息对象stats\r\n\r\n在stats对象中可以通过以下属性和方法获取信息:\r\n\r\n	stats.birthtime 创建日期, 默认显示格林威治时区\r\n	stats.size 大小\r\n	stats.isFile() 判断是否为文件\r\n	stats.isDirectory() 判断是否为目录 \r\n\r\n#### copyFile方法 ####\r\n\r\n复制文件\r\n\r\n参数1: 要拷贝的源文件路径\r\n\r\n参数2: 目的地\r\n\r\n参数3: 回调函数, 回调函数中有一个参数err, 用于判断是否拷贝成功\r\n\r\n如果目的地文件已存在, 会直接覆盖\r\n\r\n### path模块 ###\r\n\r\njoin方法 : 用来拼接路径片段\r\n\r\n参数1: 可变参数(可以传1-N个参数), 路径片段\r\n\r\n	path.join(\'/foo\', \'bar\', \'./baz/asdf\', \'quux\', \'..\');\r\n	// 返回: \'/foo/bar/baz/asdf\'\r\n\r\n在路径片段中支持.和..操作, 分别表示当前目录和上一级目录, 传入的参数必须是字符串, 返回的结果也是字符串(拼接好的路径)\r\n\r\n### CommonJS规范 ###\r\n\r\nnode.js实现了CommonJS规范, 在CommonJS规范中要求有:\r\n\r\n1. require函数\r\n2. exports对象\r\n3. module对象\r\n\r\n注意: 模块加载是同步的, 因为在服务器端开发模块都是下载到本地的, 加载速度非常快, 所以此规范不适用于浏览器中开发\r\n\r\n### 作用域 ###\r\n\r\n一个js文件可以理解为一个模块, 每个模块都有自己私有的作用域, 被称为模块作用域\r\n\r\n#### 全局作用域 ####\r\n\r\n在模块中的global对象就是全局作用域, 如果需要将模块1中的成员共享给模块2中使用, 可以选择在模块1中将成员挂载到global对象中:\r\n\r\n模块1.js:\r\n\r\n	var a = 10\r\n	global.a = a\r\n\r\n在模块2中要先引入模块1.js, 才可以使用global.a\r\n\r\n模块2.js:\r\n\r\n	const m1 = require(\'./01.模块1.js\')\r\n	console.log(global.a)\r\n\r\n在开发过程中不建议在全局作用域中挂载成员, 避免全局作用域的污染\r\n\r\n#### 模块作用域 ####\r\n\r\n每个js文件内部都是单独的模块作用域, 每个模块作用域相互无法访问对方的方法或属性\r\n\r\n模块与模块之间共享成员\r\n\r\n`exports`\r\n\r\n如果需要导出本模块中的成员, 可以将需要导出的成员挂载到exports对象身上:\r\n\r\nm1.js:\r\n\r\n	var a = 1\r\n	function sayHi() {}\r\n	exports.a = a\r\n	exports.sayHi = sayHi\r\n\r\n其他模块导入\r\n\r\nm2.js:\r\n\r\n	const m1 = require(\'./m1.js\')\r\n	console.log(m1.a)\r\n	m1.sayHi()\r\n\r\nexports其实就是module.exports\r\n\r\n但是更推荐使用module.exports, 因为导出成员时始终都是以module.exports为准\r\n\r\n### 模块分类 ###\r\n\r\n1. 核心模块\r\n2. 第三方模块\r\n\r\n### 包 ###\r\n\r\n规范:\r\n\r\n1. 包的根目录必须要有`package.json`\r\n2. `package.json`中必须具备三个属性: `name` `version` `main`\r\n\r\n		{\r\n			\"name\": \"pname\",\r\n			\"version\": 1.0.0,\r\n			\"main\": \"./lib/main.js\"\r\n		}\r\n\r\n导入包有两种方式:\r\n\r\n1. 路径标识符\r\n\r\n		// 找到当前目录的calc包中的package.json的main属性对应的js文件, 将其引入\r\n		const calc = require(\'./calc\')\r\n\r\n2. 包名标识符\r\n\r\n	在当前目录中有一个node_modules目录, 将你需要的包放在该目录中, 此时引入包可以使用包名来引入\r\n\r\n		// 去当前目录的node_modules目录中找一个叫calc的文件夹, 再去其中的package.json中找main属性对应的js文件, 将其引入\r\n		const calc = require(\'calc\')\r\n\r\n### npm ###\r\n\r\nNode Package Manager (node包管理器)\r\n\r\n常人提起npm一般指两个意思\r\n\r\n1. 命令行工具 npm\r\n2. npmjs.com 这个网站\r\n\r\n### 全局安装 ###\r\n\r\n`npm istall i5ting_toc -g`\r\n\r\n以上指令会将i5ting_toc工具安装到当前操作系统的全局区域, 安装到全局后就可以使用该工具的指令完成一些操作\r\n\r\n', '2018-11-09 08:35:16', '10');
INSERT INTO `articles` VALUES ('19', 'nodejsDay01', '## Node.js day01 ##\r\n\r\n### Node简介 ###\r\n\r\n	node的JavaScript解析器就是V8引擎\r\n\r\n	在node中没有DOM和BOM的概念, 由以下三部分组成:\r\n\r\n		1. ECMAScript\r\n		2. 全局成员\r\n		3. 核心模块API\r\n\r\n	学习目标: 使用node平台搭建一个后台服务器, 进行后端开发\r\n\r\nREPL环境: Read Eval Print Loop  同浏览器控制台\r\n\r\n### ES6语法介绍 ###\r\n\r\n#### let关键字 ####\r\n\r\n定义变量\r\n\r\n因为`var`关键字存在一些问题:\r\n\r\n1. 没有块级作用域\r\n\r\n		for (var i = 0; i < 10; i++) {\r\n\r\n		}\r\n\r\n		console.log(i) // 10\r\n\r\n\r\n2. 变量声明提升\r\n\r\n		console.log(a); // undefined\r\n		var a;\r\n\r\n如果使用`let`关键字则不存在以上两个问题:\r\n\r\n	\r\n		for (let i = 0; i < 10; i++) {\r\n\r\n		}\r\n\r\n		console.log(i) // 报错: i is not defined\r\n\r\n\r\n		console.log(a); // 报错: a is not defined\r\n		let a;\r\n\r\n总结: 使用`let`关键字声明变量的特点主要就是有块级作用域, 并且必须先声明再使用, 否则会报错, 没有变量声明提升的概念\r\n\r\n#### const关键字 ####\r\n\r\n定义常量\r\n\r\n	const a = 10;  // 从此以后a不能被重新赋值\r\n\r\n	a + 1; // 没有对a赋值 所以不会报错\r\n\r\n	a += 1; // 报错: Assignment to constant variable\r\n\r\n	const b; // 报错: Missing initializer in const declaration\r\n\r\n总结:\r\n\r\n1. 定义常量时必须要给初始值\r\n2. 定义完常量后无法对常量进行重新赋值\r\n\r\n\r\nlet和const都必须要先声明再使用, 并且都不可以重复声明\r\n\r\n#### 解构赋值 ####\r\n\r\n解构赋值一般用于将对象中的属性值获取出来, 存在变量中使用\r\n\r\n	let user = {\r\n		name: \'刘希晗\',\r\n		age: 18,\r\n		gender: \'男\'\r\n	}\r\n\r\n	// 开发中如果需要将对象的属性值提取出来在变量中使用: \r\n	let uname = user.name;\r\n\r\n	// ES6新语法, 将对象中属性批量提取到变量中:\r\n	let { name:username, age } = user;\r\n	console.log(username);\r\n	console.log(age);\r\n\r\n#### 箭头函数 ####\r\n\r\nES6中提出的一种新型匿名函数的语法:\r\n\r\n也可以理解为一种语法糖\r\n\r\n	let 函数名 = (形参1, 形参2) => {\r\n 		// 函数体\r\n	}\r\n\r\n特点: **指向外部函数的this, 语法较为简单**\r\n\r\n注意: 绑定事件时千万不要使用箭头函数, 因为使用function绑定事件处理函数, 内部的this指向事件源, 如果使用箭头函数绑定, 则不会指向事件源\r\n\r\n箭头函数的几种变体:\r\n\r\n1. 函数只有一个形参, 那么左侧的`()`可以省略\r\n\r\n		let fn1 = (a) => {\r\n			return a + 1;\r\n		}\r\n\r\n		let fn2 = a => {\r\n			return a + 1;\r\n		}\r\n\r\n2. 函数体中只有一行代码, 那么右侧的`{}`可以省略并且省略`return`, 默认会返回右侧代码执行的结果\r\n\r\n		let fn1 = (a, b) => {\r\n			return a + b;\r\n		}\r\n\r\n		let fn2 = (a, b) => a + b\r\n			\r\n3. 结合以上两点, 如果只有一个形参, 并且函数体中只有一行代码, 那么两侧的`(){}`都可以省略\r\n\r\n		let fn1 = (a) => {\r\n			return a + 1;\r\n		}\r\n\r\n		let fn2 = a => a + 1\r\n\r\n注意事项: 只有一个形参的情况下可以省略左侧的`()`, 其他情况有多个参数或者没有参数都必须加上`()`\r\n\r\n#### 声明对象属性的简洁语法 ####\r\n\r\n以前创建对象属性的字面量:\r\n\r\n	var name = \'刘希晗\';\r\n	var age = 18;\r\n	var weight = 80;\r\n\r\n	var user = {\r\n		name: name,\r\n		age: age,\r\n		weight: weight,\r\n		eat: function(food) {\r\n			console.log(\'吃了十斤\' + food);\r\n		}\r\n	}\r\n\r\nES6新语法:\r\n\r\n	let name = \'刘希晗\';\r\n	let age = 18;\r\n	let weight = 80;\r\n	let gender = \'女\';\r\n\r\n	let user = {\r\n		name,\r\n		age,\r\n		weight,\r\n		gender,\r\n		eat(food) {\r\n			console.log(\'吃了十斤\' + food);\r\n		},\r\n		sleep() {\r\n			console.log(\'上课睡觉真舒服\');\r\n		}\r\n	}\r\n\r\n\r\n### 内置模块 ###\r\n\r\n#### fs ####\r\n\r\nfs模块: File System 文件系统, node提供用于操作文件或目录的API都在该模块中\r\n\r\n1. 读取文件\r\n\r\n		readFile()\r\n\r\n		参数1: 要读取的文件路径, 如果是相对路径表示相对于当前执行node命令的路径, 而非相对当前文件, 如果需要相对当前文件路径, 请使用: __dirname进行拼接\r\n\r\n		参数2: 编码, 一般情况都需要指定编码, 默认值为null\r\n\r\n		参数3: 回调函数, 读取完文件后会执行, 有两个参数, 第一个参数为err, 第二个参数是读取的数据data\r\n\r\n2. 写入文件, 会覆盖文件\r\n\r\n		writeFile()\r\n\r\n		参数1: 要读取的文件路径, 如果是相对路径表示相对于当前执行node命令的路径, 而非相对当前文件, 如果需要相对当前文件路径, 请使用: __dirname进行拼接\r\n\r\n		参数2: 要写的数据内容\r\n\r\n		可选参数3: 编码, 默认为utf8, 一般就使用默认的\r\n\r\n		参数4: 回调函数, 写入完文件后会执行, 有一个参数err写入失败时会有数据, 如果err为null表示写入成功\r\n\r\n3. 追加文件, 在文件末尾继续追加\r\n\r\n		appendFile()\r\n\r\n		参数1: 要读取的文件路径, 如果是相对路径表示相对于当前执行node命令的路径, 而非相对当前文件, 如果需要相对当前文件路径, 请使用: __dirname进行拼接\r\n\r\n		参数2: 要写的数据内容\r\n\r\n		可选参数3: 编码, 默认为utf8, 一般就使用默认的\r\n\r\n		参数4: 回调函数, 写入完文件后会执行, 有一个参数err写入失败时会有数据, 如果err为null表示写入成功\r\n\r\n写入文件和追加文件都有共同的特点, 如果要写入的目录下文件不存在, 会自动创建文件并写入/追加\r\n\r\n全局成员: __dirname, 获取当前文件所在的绝对路径\r\n\r\n因为在node中使用相对路径都是相对于当前执行node指令的目录, 所以才会有__dirname和__filename的存在\r\n', '2018-11-08 21:55:19', '10');
INSERT INTO `articles` VALUES ('21', 'nodejsDay03', '## node day03 ##\r\n\r\n### npm指令 ###\r\n\r\n**安装全局包**\r\n\r\n`npm install 包名 -g`\r\n\r\n**卸载全局包**\r\n\r\n`npm uninstall 包名 -g`\r\n\r\n**安装本地包(将包装在项目的node_modules,其他人无法使用仅供当前项目使用)**\r\n\r\n`npm install 包名`\r\n\r\n**卸载本地包**\r\n\r\n`npm uninstall 包名`\r\n\r\n**初始化npm项目目录**\r\n\r\n`npm init` 可以自定义配置来初始化\r\n\r\n`npm init -y` 使用默认配置\r\n\r\n`npm install`的常用的参数:\r\n\r\n	--save  :  会将依赖包添加到当前项目的package.json的dependencies节点下\r\n	--save-dev  :  会将依赖包添加到当前项目的package.json的devDependencies节点下\r\n	--production  :  只安装dependencies节点下的依赖包\r\n\r\ndependencies节点: 记录的是当前项目任何阶段所依赖的包\r\n\r\ndevDependencies节点: 记录的是当前项目开发阶段所依赖的包, 项目上线后不需要依赖这些包\r\n\r\n注意: 在NPM5.x以后, --save都可以省略, 直接npm install会默认将包加入dependencies节点下\r\n\r\n`--save`简写为`-S`\r\n\r\n`--save-dev`简写为`-D`\r\n\r\n`npm install` 简写为 `npm i`\r\n\r\npackage.json文件:\r\n\r\n所有npm项目都需要有该文件, 在项目的根目录下, 该文件中有三个必须的节点:\r\n\r\n1. name\r\n2. version\r\n3. main\r\n\r\n如果当前项目依赖了其他的包, 则会把依赖的包名和版本号记录在dependencies节点下\r\n\r\n还会把具体的版本信息以及下载地址记录在 package-lock.json文件, 为了提高后期的下载速度\r\n\r\n### 使用cnpm提高下载速度 ###\r\n\r\n1. 安装cnpm包到全局\r\n\r\n		npm install cnpm -g\r\n\r\n2. 使用cnpm  用法同npm, 只需要把指令换成cnpm即可\r\n\r\n		cnpm install 包名\r\n\r\nB/S : Browser Server\r\nC/S : Client Server\r\n\r\n### http模块 ###\r\n\r\n创建一个最基本的web服务器\r\n\r\n	// 1. 引入http模块\r\n	const http = require(\'http\')\r\n\r\n	// 2. 创建http服务器\r\n	const httpServer = http.createServer();\r\n\r\n	// 3. 绑定request事件\r\n	httpServer.on(\'request\', (req, res) => {\r\n		// 处理业务逻辑\r\n		res.end(\'hello itheima\')\r\n	})\r\n\r\n	// 4. 开启服务器 listen\r\n	httpServer.listen(\'3000\', \'127.0.0.1\', () => {\r\n		console.log(\'开启服务器成功!请访问: http://127.0.0.1:3000\') \r\n	})\r\n\r\n解决中文乱码问题, 在响应之前添加响应头信息:\r\n\r\n	res.writeHeader(200, {\r\n		\'Content-Type\': \'text/plain;charset=utf-8\'\r\n	})\r\n\r\n获取客户端请求的URL:\r\n\r\n	req.url\r\n\r\n\r\nMIME类型, 在网络传输中起到了标识的作用, 根据后缀名来划分的类型:\r\n\r\n	text/plain   纯文本  .txt\r\n	text/html	 HTML数据  .html\r\n	image/jpeg	 jpg/jpeg图片  .jpg/.jpeg\r\n	image/gif	 gif图片  .gif\r\n\r\n### nodemon工具的介绍 ###\r\n\r\n因为每次修改服务器的代码后都需要重新运行服务器才可以让最新的代码生效, 所以有个小机灵鬼创造了一个小工具 --> nodemon\r\n\r\n该工具的作用非常简单, 当服务器代码发生改变时自动重启服务器\r\n\r\n安装:\r\n\r\n	npm install nodemon -g\r\n\r\n### express基本用法 ###\r\n\r\n1. 安装express包\r\n\r\n		npm install express\r\n\r\n2. 代码中引入express包\r\n\r\n		const express = require(\'express\')\r\n\r\n3. 调用express函数创建服务器\r\n\r\n		const app = express()\r\n\r\n4. 监听用户的请求\r\n\r\n		app.get(\'/\', (req, res) => {\r\n			// 原生http模块的方法返回数据\r\n			// res.end()\r\n			// express封装的方法, 也可以向客户端返回数据并且解决了乱码的问题\r\n			res.send()\r\n		})\r\n\r\n5. 开启服务器\r\n\r\n		app.listen(3000, () => {\r\n			console.log(\'服务器启动成功, 请访问:http://127.0.0.1:3000\') \r\n		})', '2018-11-09 08:35:55', '10');
INSERT INTO `articles` VALUES ('22', 'nodejsDay04', '## node day04 ##\r\n\r\n### express常用方法 ###\r\n\r\n	const express = require(\'express\')\r\n\r\n	const app = express()\r\n\r\n	app.get(\'/\', (req, res) => {\r\n		// res.send()\r\n		// res.sendFile()\r\n	})\r\n\r\n	app.listen(3000, () => {\r\n		console.log(\'服务器开启成功!\')\r\n	})\r\n\r\n`res.send`: 可以用来向客户端响应数据, 支持的数据类型有以下三种:\r\n\r\n1. 字符串 \'\'   返回客户端普通字符串\r\n2. 对象或数组 {} []  返回客户端JSON字符串\r\n3. 二进制 Buffer   返回客户端二进制提示下载\r\n\r\n`res.sendFile`: 可以用来向客户端响应文件, 直接可以将HTML页面返回\r\n\r\n参数1: 路径, 如果只传入一个参数, 该路径必须是绝对路径\r\n\r\n参数2: 如果第一个参数传入的是相对路径, 第二个参数必须指定相对路径相对于哪个绝对路径, root\r\n\r\n	// 只用一个参数的方式\r\n	res.sendFile(path.join(__dirname, \'./views/index.html\'))\r\n\r\n	// 用两个参数的方式\r\n	res.sendFile(\'./views/index.html\', {\r\n		root: __dirname\r\n	})\r\n\r\n### 注册静态资源托管的中间件 ###\r\n\r\n	// 托管./views目录下的静态资源\r\n	app.use(express.static(\'./views\'))\r\n\r\n\r\n	// 参数1: 虚拟目录, 当传入该参数之后客户端请求./views目录下的静态资源时需要加上前缀pages\r\n	app.use(\'pages\', express.static(\'./views\'))\r\n\r\n### ejs简介 ###\r\n\r\nejs是服务端比较常用的一个模板引擎, 和artTemplate类似\r\n\r\n使用ejs的步骤:\r\n\r\n1. 在项目中安装ejs\r\n\r\n	`npm install ejs`\r\n\r\n2. 在express中配置模板引擎\r\n\r\n	`app.set(\'view engine\', \'ejs\')`\r\n\r\n3. 配置模板页面所在的路径\r\n\r\n	`app.set(\'views\', \'./ejs_pages\')`\r\n\r\n4. 当用户请求数据时, 做出响应之前可以进行模板引擎的渲染\r\n\r\n	`res.render(\'index.ejs\', {})`\r\n\r\n### 在express中自定义模板引擎 ###\r\n\r\n用art-template举例\r\n\r\n1. 装两个包art-template express-art-template\r\n\r\n2. 自定义模板引擎\r\n\r\n	`app.engine(\'html\', require(\'express-art-template\'))`\r\n\r\n3. 在express中配置模板引擎\r\n\r\n	`app.set(\'view engine\', \'html\')`\r\n\r\n4. 配置模板页面所在的路径\r\n\r\n	`app.set(\'views\', \'./art_pages\')`\r\n\r\n5. 当用户请求数据时, 做出响应之前可以进行模板引擎的渲染\r\n\r\n	`res.render(\'index.html\', {})`\r\n\r\n### 封装express的路由模块 ###\r\n\r\n路由: 前端向后台请求某个资源, 后台收到请求后将作出对应的处理, 例如:\r\n\r\n	前端向URL发送请求:　/getUsers\r\n\r\n	后台根据 /getUsers 接口地址作出对应的响应就被称为路由\r\n\r\n主程序代码:\r\n\r\n	const express = require(\'express\')\r\n	const app = express()\r\n	\r\n	// 1. 导入路由对象\r\n	const router = require(\'./09.router.js\')\r\n	// 2. 调用 app.use 方法，安装路由模块\r\n	app.use(router)\r\n	\r\n	app.listen(3000, () => {\r\n	  console.log(\'server running at http://127.0.0.1:3000\')\r\n	})\r\n\r\n路由模块:\r\n\r\n1. 引入express框架\r\n\r\n	`const express = require(\'express\')`\r\n\r\n2. 创建路由对象\r\n\r\n	`const router = express.Router()`\r\n\r\n3. 挂载路由规则\r\n \r\n		router.get(\'/movie\', (req, res) => {\r\n			res.sendFile(\'./views/movie.html\', , { root: __dirname })\r\n		})\r\n\r\n\r\n4. 导出路由对象供外界使用\r\n\r\n	`module.exports = router`\r\n\r\n### 中间件 ###\r\n\r\n定义：中间件就是一个处理函数；只不过这个函数比较特殊，包含了三个参数，分别是 req，res，next\r\n\r\n注意：中间件方法中的三个参数：\r\n\r\n- req：请求对象；\r\n- res：响应对象；\r\n- next：next()可以被调用，表示调用下一个中间件方法；\r\n\r\n### Express 框架中对中间件的5种分类 ###\r\n\r\n1. 应用级别的中间件： 挂载到 app 上的中间件 app.get(\'URL地址\', （req, res, next）=> {})；\r\n2. 路由级别的中间件： 挂载到 router 对象上的中间件  router.get(\'url地址\', (req, res, next)=>{})\r\n3. 错误级别的中间件： 回调函数中，有四个参数 app.use((err, req, res, next)=>{})\r\n4. 唯一内置的中间件： express.static()\r\n5. 第三方中间件： 非express框架提供的，需要程序员手动安装才能使用的中间件；body-parser 解析post 表单数据\r\n\r\n中间件的概念，了解即可，因为实际开发中，我们都直接使用第三方现成的中间件；\r\n\r\n### 自定义post请求参数解析的中间件 ###\r\n\r\n	// 导入 express 模块\r\n	const express = require(\'express\')\r\n	const querystring = require(\'querystring\')\r\n	// 创建 express 的服务器实例\r\n	const app = express()\r\n	\r\n	// 定义 应用级别的中间件 只要客户端请求服务器就会触发回调函数的执行\r\n	app.use((req, res, next) => {\r\n	  let dataStr = \'\'\r\n	  // 只要客户端向服务器提交了表单，都会触发 req 的 data 事件\r\n	  // 在 data 事件中，可以获取到客户端每次提交过来的，不完整的数据\r\n	  req.on(\'data\', chunk => {\r\n	    dataStr += chunk\r\n	  })\r\n	\r\n	  // 只要 req 触发了 end 事件，就表示表单数据，提交完毕了，dataStr 中存储的数据，就是完整的表单数据\r\n	  req.on(\'end\', () => {\r\n	    console.log(dataStr)\r\n	    const obj = querystring.parse(dataStr)\r\n	    // 想要把 username=ls&password=123 字符串，解析为 { username: \'ls\', password: 123 }\r\n	    console.log(obj)\r\n	    req.body = obj\r\n	    // 进入下一个中间件的处理环节；\r\n	    // 注意：在中间件中，最后，一定要合理的调用一下 next() 方法，否则，服务器 无法结束这次响应！\r\n	    next()\r\n	  })\r\n	})\r\n	\r\n	// 这是应用级别的中间件\r\n	app.get(\'/\', (req, res) => {\r\n	  res.sendFile(\'./11.index.html\', { root: __dirname })\r\n	})\r\n	\r\n	app.post(\'/postdata\', (req, res) => {\r\n	  console.log(req.body)\r\n	  // 需求：如何从客户端提交的表单中，获取到 客户端提交过来的数据呢？\r\n	  res.send(req.body)\r\n	})\r\n	\r\n	// 调用 app.listen 方法，指定端口号并启动web服务器\r\n	app.listen(3001, function() {\r\n	  console.log(\'Express server running at http://127.0.0.1:3001\')\r\n	})\r\n\r\n### MySQL模块 ###\r\n\r\n在node中连接MySQL数据库的工具模块\r\n\r\n1. 安装MySQL模块\r\n\r\n		npm install mysql\r\n\r\n2. 引入MySQL模块\r\n\r\n		const mysql = require(\'mysql\')\r\n\r\n3. 创建连接\r\n\r\n		const conn = mysql.createConnection({\r\n			host     : \'localhost\',\r\n			user     : \'root\',\r\n			password : \'root\',\r\n			database : \'my001\'\r\n		});\r\n\r\n4. 执行sql语句\r\n\r\n		// 查询语句 不需要补充sql\r\n		const selectSql = \'select * from users\'\r\n		conn.query(selectSql, (err, result) => {\r\n			if (err) return console.log(err.message)\r\n			console.log(result)\r\n		})\r\n	\r\n		// 插入语句 set ? 语法只有在node的MySQL模块中才能使用, 其他地方无法使用 还是记忆标准的sql语法\r\n		// 标准的插入语句: insert into users values (\'\', \'zs\', \'18\', \'男\')\r\n		const insertSql = \'insert into users set ?\'\r\n		const user = {uname: \'zs\', age: \'18\', gender: \'男\'}\r\n		conn.query(insertSql, user, (err, result) => {\r\n			if (err) return console.log(err.message)\r\n			console.log(result)\r\n		})\r\n	\r\n		// 修改语句\r\n		const updateSql = \'update users set ? where id = ?\'\r\n		const user = {id: 1, uname: \'ls\', age: \'22\', gender: \'男\'}\r\n		conn.query(updateSql, [user, user.id], (err, result) => {\r\n			if (err) return console.log(err.message)\r\n			console.log(result)\r\n		})\r\n	\r\n		// 删除语句\r\n		const deleteSql = \'delete from users where id = ?\'\r\n		conn.query(deleteSql, \'1\', (err, result) => {\r\n			if (err) return console.log(err.message)\r\n			console.log(result)\r\n		})\r\n	\r\n\r\n', '2018-11-09 09:58:57', '10');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `nickname` varchar(255) NOT NULL,
  `ctime` varchar(255) NOT NULL,
  `isDel` tinyint(4) NOT NULL DEFAULT '0' COMMENT '0表示正常 1表示禁止',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('10', 'root', '$2b$10$bmCFoINbTWM80sweyzC8KuYWimx7Gw.vl3qyOKJzq0a1bdJcxaxxq', '晓与斑', '2018-11-08 09:54:43', '0');
